import os
import re
import openai
from dotenv import load_dotenv
from typing import List, Tuple


load_dotenv()
openai.api_key = os.getenv('OPENAI_API_KEY')


class Story:
    """Madlibs story.

    To  make a story, pass a list of prompts, and the text
    of the template.

        >>> s = Story(["noun", "verb"],
        ...     "I love to {verb} a good {noun}.")

    To generate text from a story, pass in a dictionary-like thing
    of {prompt: answer, ...):

        >>> ans = {"verb": "eat", "noun": "mango"}
        >>> s.generate(ans)
        'I love to eat a good mango.'
    """

    def __init__(self, words, text, uniques=[]):
        """Create a Story object with prompts, template text, and unique
        prompts.

        This method creates a new Story object with the given prompts (i.e. the
        terms to be filled in by the user), the template text (i.e. the text
        that will be modified by the user's answers), and a list of unique
        prompts. If the uniques argument is not provided, it defaults to an
        empty list.

        Args:
            words (list of str): A list of prompts to be filled in by the user.
            text (str): The template text that will be modified by the user's
            answers. uniques (list of str, optional): A list of unique prompts.
            Defaults to an
                empty list.

        Returns:
            Story: A new Story object with the given prompts, template text, and
            unique prompts.
        """

        self.prompts = words
        self.template = text
        self.uniques = uniques
        self.responses = {}

    def generate(self, answers):
        """Substitute user answers into template text.

        This method replaces the prompt placeholders (i.e. curly-braced terms)
        in the Story's template text with the user's answers. The answers should
        be provided as a dictionary, with the keys corresponding to the prompts
        and the values corresponding to the user's answers.

        Args:
            answers (dict): A dictionary of user answers, with the keys
            corresponding to
                the prompts and the values corresponding to the user's answers.

        Returns:
            str: A string containing the template text with the prompt
            placeholders replaced by the user's answers.
        """
        text = self.template

        for (key, val) in answers.items():
            text = text.replace("{" + key + "}", val)

        return text


def create_ai_story():
    """Create a story using the OpenAI GPT-3 language model.

    This function fetches a story generated by the GPT-3 language model,
    extracts the terms enclosed in curly braces from the story, and returns a
    Story object containing the original story, the terms, and the unique terms.

    Returns:
        Story: A Story object representing the generated story and the terms
        extracted from it.
    """

    content = fetch_gpt_story()
    (terms, uniques) = extract_terms(content)

    return Story(terms, content, uniques)


def fetch_gpt_story():
    """Fetch a story generated by the OpenAI GPT-3 language model.

    This function sends a prompt to the OpenAI API containing system and user
    instructions for generating a story, and returns the generated story.

    Returns:
        str: A string containing the generated story.
    """
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system",
             "content": os.getenv('MADLIBS_SYSTEM_INSTRUCTIONS')},
            {"role": "user",
             "content": os.getenv('MADLIBS_USER_INSTRUCTIONS')}
        ]
    )

    return response['choices'][0]['message']['content']


def extract_terms(text):
    """Extract terms enclosed in curly braces from a string.

    This function searches a string for substrings enclosed in curly braces
    (e.g. "{term}"), and returns two lists: one with all the terms found in the
    string, and another with only the unique terms.

    Args:
        text (str): The text to search for terms.

    Returns:
        tuple: A tuple containing two lists. The first list contains all the
        terms found in the string, in the order they were found. The second list
        contains only the unique terms found in the string, in the order they
        were first encountered.
    """
    pattern = r'\{([^}]+)\}'
    terms = re.findall(pattern, text, flags=re.IGNORECASE)
    deduped_terms = list(set(terms))
    uniques = create_uniques_list(deduped_terms)
    return terms, uniques


def create_uniques_list(lst: List[str]) -> List[Tuple[str, str]]:
    """Extract unique prompts from a list of prompt strings.

    This function takes a list of unique, coded strings and extracts from
    them the codeded portion. For each coded strings, a tuple is created
    containing the original coded string and its non-coded variation. These
    tuples are then returned in a list.

    Args:
        lst (List[str]): A list of prompt strings.

    Returns:
        List[Tuple[str, str]]: A list of tuples containing the original prompt
        with coded number and a user-facing version without the coding.
    """

    result = []

    for term in lst:
        pattern = r'__'
        match = re.search(pattern, term)
        if match is not None:
            position = match.start()
            just_term = term[:position]
            result.append((term, just_term))
        else:
            raise TypeError

    return result

# Here's a story to get you started
silly_story = Story(
    ["place", "noun", "verb", "adjective", "plural_noun"],
    """Once upon a time, in a long-ago {place}, there lived an exceptionally
       {adjective} {noun}. It loved to {verb} with {plural_noun}."""
)

# Here's another --- you should be able to swap in app.py to use this story,
# and everything should still work

excited_story = Story(
    ["noun", "verb"],
    """OMG!! OMG!! I love to {verb} a {noun}!"""
)

ai_story = create_ai_story()
